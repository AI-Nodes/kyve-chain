// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/bundles/v1beta1/events.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventBundleVote is an event emitted when a protocol node votes on a bundle.
// emitted_by: MsgVoteBundleProposal
type EventBundleVote struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// staker is the account staker of the protocol node.
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// storage_id is the unique ID of the bundle.
	StorageId string `protobuf:"bytes,3,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// vote is for what the validator voted with
	Vote VoteType `protobuf:"varint,4,opt,name=vote,proto3,enum=kyve.bundles.v1beta1.VoteType" json:"vote,omitempty"`
}

func (m *EventBundleVote) Reset()         { *m = EventBundleVote{} }
func (m *EventBundleVote) String() string { return proto.CompactTextString(m) }
func (*EventBundleVote) ProtoMessage()    {}
func (*EventBundleVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{0}
}
func (m *EventBundleVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBundleVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBundleVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBundleVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBundleVote.Merge(m, src)
}
func (m *EventBundleVote) XXX_Size() int {
	return m.Size()
}
func (m *EventBundleVote) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBundleVote.DiscardUnknown(m)
}

var xxx_messageInfo_EventBundleVote proto.InternalMessageInfo

func (m *EventBundleVote) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventBundleVote) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *EventBundleVote) GetStorageId() string {
	if m != nil {
		return m.StorageId
	}
	return ""
}

func (m *EventBundleVote) GetVote() VoteType {
	if m != nil {
		return m.Vote
	}
	return VOTE_TYPE_UNSPECIFIED
}

// EventBundleProposed is submitted by the MsgSubmitBundleProposal message
// emitted_by: MsgSubmitBundleProposal
type EventBundleProposed struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// internal id for the KYVE-bundle
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// storage_id is the ID to retrieve to data item from the configured storage provider
	// e.g. the ARWEAVE-id
	StorageId string `protobuf:"bytes,3,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// Address of the uploader/proposer of the bundle
	Uploader string `protobuf:"bytes,4,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// data_size size in bytes of the data
	DataSize uint64 `protobuf:"varint,5,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	// from_index starting index of the bundle (inclusive)
	FromIndex uint64 `protobuf:"varint,6,opt,name=from_index,json=fromIndex,proto3" json:"from_index,omitempty"`
	// bundle_size amount of data items in the bundle
	BundleSize uint64 `protobuf:"varint,7,opt,name=bundle_size,json=bundleSize,proto3" json:"bundle_size,omitempty"`
	// from_key the key of the first data item in the bundle
	FromKey string `protobuf:"bytes,8,opt,name=from_key,json=fromKey,proto3" json:"from_key,omitempty"`
	// to_key the key of the last data item in the bundle
	ToKey string `protobuf:"bytes,9,opt,name=to_key,json=toKey,proto3" json:"to_key,omitempty"`
	// bundle_summary is a short string holding some useful information of
	// the bundle which will get stored on-chain
	BundleSummary string `protobuf:"bytes,10,opt,name=bundle_summary,json=bundleSummary,proto3" json:"bundle_summary,omitempty"`
	// data_hash is a sha256 hash of the raw compressed data
	DataHash string `protobuf:"bytes,11,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	// proposed_at the unix time when the bundle was proposed
	ProposedAt uint64 `protobuf:"varint,12,opt,name=proposed_at,json=proposedAt,proto3" json:"proposed_at,omitempty"`
	// storage_provider_id the unique id of the storage provider where
	// the data of the bundle is tored
	StorageProviderId uint32 `protobuf:"varint,13,opt,name=storage_provider_id,json=storageProviderId,proto3" json:"storage_provider_id,omitempty"`
	// compression_id  the unique id of the compression type the data
	// of the bundle was compressed with
	CompressionId uint32 `protobuf:"varint,14,opt,name=compression_id,json=compressionId,proto3" json:"compression_id,omitempty"`
}

func (m *EventBundleProposed) Reset()         { *m = EventBundleProposed{} }
func (m *EventBundleProposed) String() string { return proto.CompactTextString(m) }
func (*EventBundleProposed) ProtoMessage()    {}
func (*EventBundleProposed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{1}
}
func (m *EventBundleProposed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBundleProposed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBundleProposed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBundleProposed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBundleProposed.Merge(m, src)
}
func (m *EventBundleProposed) XXX_Size() int {
	return m.Size()
}
func (m *EventBundleProposed) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBundleProposed.DiscardUnknown(m)
}

var xxx_messageInfo_EventBundleProposed proto.InternalMessageInfo

func (m *EventBundleProposed) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventBundleProposed) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventBundleProposed) GetStorageId() string {
	if m != nil {
		return m.StorageId
	}
	return ""
}

func (m *EventBundleProposed) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *EventBundleProposed) GetDataSize() uint64 {
	if m != nil {
		return m.DataSize
	}
	return 0
}

func (m *EventBundleProposed) GetFromIndex() uint64 {
	if m != nil {
		return m.FromIndex
	}
	return 0
}

func (m *EventBundleProposed) GetBundleSize() uint64 {
	if m != nil {
		return m.BundleSize
	}
	return 0
}

func (m *EventBundleProposed) GetFromKey() string {
	if m != nil {
		return m.FromKey
	}
	return ""
}

func (m *EventBundleProposed) GetToKey() string {
	if m != nil {
		return m.ToKey
	}
	return ""
}

func (m *EventBundleProposed) GetBundleSummary() string {
	if m != nil {
		return m.BundleSummary
	}
	return ""
}

func (m *EventBundleProposed) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *EventBundleProposed) GetProposedAt() uint64 {
	if m != nil {
		return m.ProposedAt
	}
	return 0
}

func (m *EventBundleProposed) GetStorageProviderId() uint32 {
	if m != nil {
		return m.StorageProviderId
	}
	return 0
}

func (m *EventBundleProposed) GetCompressionId() uint32 {
	if m != nil {
		return m.CompressionId
	}
	return 0
}

// EventBundleFinalized is an event emitted when a bundle is finalised.
// emitted_by: MsgSubmitBundleProposal, EndBlock
type EventBundleFinalized struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// internal id for the KYVE-bundle
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// total voting power which voted for valid
	Valid uint64 `protobuf:"varint,3,opt,name=valid,proto3" json:"valid,omitempty"`
	// total voting power which voted for invalid
	Invalid uint64 `protobuf:"varint,4,opt,name=invalid,proto3" json:"invalid,omitempty"`
	// total voting power which voted for abstain
	Abstain uint64 `protobuf:"varint,5,opt,name=abstain,proto3" json:"abstain,omitempty"`
	// total voting power of the pool
	Total uint64 `protobuf:"varint,6,opt,name=total,proto3" json:"total,omitempty"`
	// status of the finalized bundle
	Status BundleStatus `protobuf:"varint,7,opt,name=status,proto3,enum=kyve.bundles.v1beta1.BundleStatus" json:"status,omitempty"`
	// rewards transferred to treasury (in ukyve)
	RewardTreasury uint64 `protobuf:"varint,8,opt,name=reward_treasury,json=rewardTreasury,proto3" json:"reward_treasury,omitempty"`
	// rewardUploader rewards directly transferred to uploader (in ukyve)
	RewardUploader uint64 `protobuf:"varint,9,opt,name=reward_uploader,json=rewardUploader,proto3" json:"reward_uploader,omitempty"`
	// rewardDelegation rewards distributed among all delegators (in ukyve)
	RewardDelegation uint64 `protobuf:"varint,10,opt,name=reward_delegation,json=rewardDelegation,proto3" json:"reward_delegation,omitempty"`
	// rewardTotal the total bundle reward
	RewardTotal uint64 `protobuf:"varint,11,opt,name=reward_total,json=rewardTotal,proto3" json:"reward_total,omitempty"`
	// finalized_at the block height where the bundle got finalized
	FinalizedAt uint64 `protobuf:"varint,12,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// uploader the address of the uploader of this bundle
	Uploader string `protobuf:"bytes,13,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// next_uploader the address of the next uploader after this bundle
	NextUploader string `protobuf:"bytes,14,opt,name=next_uploader,json=nextUploader,proto3" json:"next_uploader,omitempty"`
}

func (m *EventBundleFinalized) Reset()         { *m = EventBundleFinalized{} }
func (m *EventBundleFinalized) String() string { return proto.CompactTextString(m) }
func (*EventBundleFinalized) ProtoMessage()    {}
func (*EventBundleFinalized) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{2}
}
func (m *EventBundleFinalized) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBundleFinalized) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBundleFinalized.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBundleFinalized) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBundleFinalized.Merge(m, src)
}
func (m *EventBundleFinalized) XXX_Size() int {
	return m.Size()
}
func (m *EventBundleFinalized) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBundleFinalized.DiscardUnknown(m)
}

var xxx_messageInfo_EventBundleFinalized proto.InternalMessageInfo

func (m *EventBundleFinalized) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventBundleFinalized) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventBundleFinalized) GetValid() uint64 {
	if m != nil {
		return m.Valid
	}
	return 0
}

func (m *EventBundleFinalized) GetInvalid() uint64 {
	if m != nil {
		return m.Invalid
	}
	return 0
}

func (m *EventBundleFinalized) GetAbstain() uint64 {
	if m != nil {
		return m.Abstain
	}
	return 0
}

func (m *EventBundleFinalized) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *EventBundleFinalized) GetStatus() BundleStatus {
	if m != nil {
		return m.Status
	}
	return BUNDLE_STATUS_UNSPECIFIED
}

func (m *EventBundleFinalized) GetRewardTreasury() uint64 {
	if m != nil {
		return m.RewardTreasury
	}
	return 0
}

func (m *EventBundleFinalized) GetRewardUploader() uint64 {
	if m != nil {
		return m.RewardUploader
	}
	return 0
}

func (m *EventBundleFinalized) GetRewardDelegation() uint64 {
	if m != nil {
		return m.RewardDelegation
	}
	return 0
}

func (m *EventBundleFinalized) GetRewardTotal() uint64 {
	if m != nil {
		return m.RewardTotal
	}
	return 0
}

func (m *EventBundleFinalized) GetFinalizedAt() uint64 {
	if m != nil {
		return m.FinalizedAt
	}
	return 0
}

func (m *EventBundleFinalized) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *EventBundleFinalized) GetNextUploader() string {
	if m != nil {
		return m.NextUploader
	}
	return ""
}

// EventClaimedUploaderRole is an event emitted when an uploader claims the uploader role
// emitted_by: MsgClaimUploaderRole
type EventClaimedUploaderRole struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// id internal id for the KYVE-bundle
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// new_uploader the address of the participant who claimed
	// the free uploader role
	NewUploader string `protobuf:"bytes,3,opt,name=new_uploader,json=newUploader,proto3" json:"new_uploader,omitempty"`
}

func (m *EventClaimedUploaderRole) Reset()         { *m = EventClaimedUploaderRole{} }
func (m *EventClaimedUploaderRole) String() string { return proto.CompactTextString(m) }
func (*EventClaimedUploaderRole) ProtoMessage()    {}
func (*EventClaimedUploaderRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{3}
}
func (m *EventClaimedUploaderRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventClaimedUploaderRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventClaimedUploaderRole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventClaimedUploaderRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventClaimedUploaderRole.Merge(m, src)
}
func (m *EventClaimedUploaderRole) XXX_Size() int {
	return m.Size()
}
func (m *EventClaimedUploaderRole) XXX_DiscardUnknown() {
	xxx_messageInfo_EventClaimedUploaderRole.DiscardUnknown(m)
}

var xxx_messageInfo_EventClaimedUploaderRole proto.InternalMessageInfo

func (m *EventClaimedUploaderRole) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventClaimedUploaderRole) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventClaimedUploaderRole) GetNewUploader() string {
	if m != nil {
		return m.NewUploader
	}
	return ""
}

// EventSkippedUploaderRole is an event emitted when an uploader skips the upload
// emitted_by: MsgSkipUploaderRole
type EventSkippedUploaderRole struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// id internal id for the KYVE-bundle
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// previous_uploader is the address of the staker who skipped his uploader role
	PreviousUploader string `protobuf:"bytes,3,opt,name=previous_uploader,json=previousUploader,proto3" json:"previous_uploader,omitempty"`
	// new_uploader is the address of the new uploader who got automatically selected
	NewUploader string `protobuf:"bytes,4,opt,name=new_uploader,json=newUploader,proto3" json:"new_uploader,omitempty"`
}

func (m *EventSkippedUploaderRole) Reset()         { *m = EventSkippedUploaderRole{} }
func (m *EventSkippedUploaderRole) String() string { return proto.CompactTextString(m) }
func (*EventSkippedUploaderRole) ProtoMessage()    {}
func (*EventSkippedUploaderRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{4}
}
func (m *EventSkippedUploaderRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSkippedUploaderRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSkippedUploaderRole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSkippedUploaderRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSkippedUploaderRole.Merge(m, src)
}
func (m *EventSkippedUploaderRole) XXX_Size() int {
	return m.Size()
}
func (m *EventSkippedUploaderRole) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSkippedUploaderRole.DiscardUnknown(m)
}

var xxx_messageInfo_EventSkippedUploaderRole proto.InternalMessageInfo

func (m *EventSkippedUploaderRole) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventSkippedUploaderRole) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventSkippedUploaderRole) GetPreviousUploader() string {
	if m != nil {
		return m.PreviousUploader
	}
	return ""
}

func (m *EventSkippedUploaderRole) GetNewUploader() string {
	if m != nil {
		return m.NewUploader
	}
	return ""
}

// EventPointIncreased is an event emitted when a staker receives a point
// emitted_by: MsgSubmitBundleProposal, EndBlock
type EventPointIncreased struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// staker is the address of the staker who received the point
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// current_points is the amount of points the staker has now
	CurrentPoints uint64 `protobuf:"varint,3,opt,name=current_points,json=currentPoints,proto3" json:"current_points,omitempty"`
}

func (m *EventPointIncreased) Reset()         { *m = EventPointIncreased{} }
func (m *EventPointIncreased) String() string { return proto.CompactTextString(m) }
func (*EventPointIncreased) ProtoMessage()    {}
func (*EventPointIncreased) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{5}
}
func (m *EventPointIncreased) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPointIncreased) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPointIncreased.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPointIncreased) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPointIncreased.Merge(m, src)
}
func (m *EventPointIncreased) XXX_Size() int {
	return m.Size()
}
func (m *EventPointIncreased) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPointIncreased.DiscardUnknown(m)
}

var xxx_messageInfo_EventPointIncreased proto.InternalMessageInfo

func (m *EventPointIncreased) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventPointIncreased) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *EventPointIncreased) GetCurrentPoints() uint64 {
	if m != nil {
		return m.CurrentPoints
	}
	return 0
}

// EventPointIncreased is an event emitted when a staker receives a point
// emitted_by: MsgSubmitBundleProposal, EndBlock
type EventPointsReset struct {
	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// staker is the address of the staker who has zero points now
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
}

func (m *EventPointsReset) Reset()         { *m = EventPointsReset{} }
func (m *EventPointsReset) String() string { return proto.CompactTextString(m) }
func (*EventPointsReset) ProtoMessage()    {}
func (*EventPointsReset) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02f505e55d81e92, []int{6}
}
func (m *EventPointsReset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPointsReset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPointsReset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPointsReset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPointsReset.Merge(m, src)
}
func (m *EventPointsReset) XXX_Size() int {
	return m.Size()
}
func (m *EventPointsReset) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPointsReset.DiscardUnknown(m)
}

var xxx_messageInfo_EventPointsReset proto.InternalMessageInfo

func (m *EventPointsReset) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *EventPointsReset) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func init() {
	proto.RegisterType((*EventBundleVote)(nil), "kyve.bundles.v1beta1.EventBundleVote")
	proto.RegisterType((*EventBundleProposed)(nil), "kyve.bundles.v1beta1.EventBundleProposed")
	proto.RegisterType((*EventBundleFinalized)(nil), "kyve.bundles.v1beta1.EventBundleFinalized")
	proto.RegisterType((*EventClaimedUploaderRole)(nil), "kyve.bundles.v1beta1.EventClaimedUploaderRole")
	proto.RegisterType((*EventSkippedUploaderRole)(nil), "kyve.bundles.v1beta1.EventSkippedUploaderRole")
	proto.RegisterType((*EventPointIncreased)(nil), "kyve.bundles.v1beta1.EventPointIncreased")
	proto.RegisterType((*EventPointsReset)(nil), "kyve.bundles.v1beta1.EventPointsReset")
}

func init() { proto.RegisterFile("kyve/bundles/v1beta1/events.proto", fileDescriptor_a02f505e55d81e92) }

var fileDescriptor_a02f505e55d81e92 = []byte{
	// 775 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4b, 0x4f, 0x1b, 0x49,
	0x10, 0x66, 0x60, 0xf0, 0xa3, 0xfd, 0x00, 0x06, 0x76, 0x77, 0x96, 0x15, 0x5e, 0xdb, 0xab, 0xd5,
	0x5a, 0x62, 0x65, 0x0b, 0xf6, 0xb6, 0x37, 0x60, 0x41, 0x6b, 0x21, 0x45, 0x68, 0x20, 0x48, 0xc9,
	0xc5, 0x6a, 0x7b, 0x0a, 0xdc, 0xf2, 0x78, 0x7a, 0xd4, 0xdd, 0xe3, 0x07, 0xbf, 0x22, 0x52, 0x94,
	0x7f, 0x94, 0x43, 0x8e, 0x1c, 0x73, 0x4c, 0xe0, 0x8f, 0x44, 0xfd, 0x98, 0xb1, 0x43, 0x4c, 0x12,
	0x72, 0xac, 0xaf, 0xbe, 0xaa, 0xfa, 0xba, 0xbf, 0xea, 0x19, 0x54, 0x1b, 0x4c, 0x47, 0xd0, 0xea,
	0xc6, 0xa1, 0x1f, 0x00, 0x6f, 0x8d, 0xf6, 0xba, 0x20, 0xf0, 0x5e, 0x0b, 0x46, 0x10, 0x0a, 0xde,
	0x8c, 0x18, 0x15, 0xd4, 0xd9, 0x92, 0x94, 0xa6, 0xa1, 0x34, 0x0d, 0x65, 0xbb, 0xbe, 0xb0, 0x30,
	0x61, 0xa9, 0xca, 0xed, 0x9d, 0x85, 0x1c, 0x31, 0xd1, 0xe9, 0xfa, 0x1b, 0x0b, 0xad, 0x1d, 0xcb,
	0x49, 0x87, 0x8a, 0x71, 0x49, 0x05, 0x38, 0xbf, 0xa0, 0x6c, 0x44, 0x69, 0xd0, 0x21, 0xbe, 0x6b,
	0x55, 0xad, 0x86, 0xed, 0x65, 0x64, 0xd8, 0xf6, 0x9d, 0x9f, 0x51, 0x86, 0x0b, 0x3c, 0x00, 0xe6,
	0x2e, 0x57, 0xad, 0x46, 0xde, 0x33, 0x91, 0xb3, 0x83, 0x10, 0x17, 0x94, 0xe1, 0x6b, 0x90, 0x35,
	0x2b, 0x2a, 0x97, 0x37, 0x48, 0xdb, 0x77, 0xf6, 0x91, 0x3d, 0xa2, 0x02, 0x5c, 0xbb, 0x6a, 0x35,
	0xca, 0xfb, 0x95, 0xe6, 0xa2, 0xb3, 0x34, 0xe5, 0xe4, 0x8b, 0x69, 0x04, 0x9e, 0xe2, 0xd6, 0xdf,
	0xae, 0xa0, 0xcd, 0x39, 0x5d, 0x67, 0x8c, 0x46, 0x94, 0x83, 0xff, 0xb8, 0xb6, 0x32, 0x5a, 0x26,
	0xbe, 0xd2, 0x65, 0x7b, 0xcb, 0xc4, 0xff, 0x96, 0xa6, 0x6d, 0x94, 0x8b, 0xa3, 0x80, 0x62, 0x1f,
	0x98, 0xd2, 0x95, 0xf7, 0xd2, 0xd8, 0xf9, 0x0d, 0xe5, 0x7d, 0x2c, 0x70, 0x87, 0x93, 0x1b, 0x70,
	0x57, 0x55, 0xc7, 0x9c, 0x04, 0xce, 0xc9, 0x0d, 0xc8, 0xbe, 0x57, 0x8c, 0x0e, 0x3b, 0x24, 0xf4,
	0x61, 0xe2, 0x66, 0x54, 0x36, 0x2f, 0x91, 0xb6, 0x04, 0x9c, 0xdf, 0x51, 0x41, 0x9f, 0x4c, 0x57,
	0x67, 0x55, 0x1e, 0x69, 0x48, 0xd5, 0xff, 0x8a, 0x72, 0xaa, 0x7e, 0x00, 0x53, 0x37, 0xa7, 0x06,
	0x67, 0x65, 0x7c, 0x0a, 0x53, 0xe7, 0x27, 0x94, 0x11, 0x54, 0x25, 0xf2, 0x2a, 0xb1, 0x2a, 0xa8,
	0x84, 0xff, 0x44, 0xe5, 0xa4, 0x65, 0x3c, 0x1c, 0x62, 0x36, 0x75, 0x91, 0x4a, 0x97, 0x4c, 0x57,
	0x0d, 0xa6, 0xaa, 0xfb, 0x98, 0xf7, 0xdd, 0x82, 0x3e, 0x92, 0x04, 0xfe, 0xc7, 0xbc, 0x2f, 0x65,
	0x45, 0xe6, 0x0a, 0x3b, 0x58, 0xb8, 0x45, 0x2d, 0x2b, 0x81, 0x0e, 0x84, 0xd3, 0x44, 0x9b, 0xc9,
	0x75, 0x45, 0x8c, 0x8e, 0x88, 0x0f, 0x4c, 0xde, 0x5b, 0xa9, 0x6a, 0x35, 0x4a, 0xde, 0x86, 0x49,
	0x9d, 0x99, 0x4c, 0xdb, 0x97, 0xa2, 0x7a, 0x74, 0x18, 0x31, 0xe0, 0x9c, 0xd0, 0x50, 0x52, 0xcb,
	0x8a, 0x5a, 0x9a, 0x43, 0xdb, 0x7e, 0xfd, 0xe3, 0x0a, 0xda, 0x9a, 0xb3, 0xf1, 0x84, 0x84, 0x38,
	0x20, 0x37, 0x4f, 0xf1, 0x71, 0x0b, 0xad, 0x8e, 0x70, 0x60, 0x2c, 0xb4, 0x3d, 0x1d, 0x38, 0x2e,
	0xca, 0x92, 0x50, 0xe3, 0xb6, 0xc2, 0x93, 0x50, 0x66, 0x70, 0x97, 0x0b, 0x4c, 0x42, 0x63, 0x5d,
	0x12, 0xca, 0x4e, 0x82, 0x0a, 0x1c, 0x18, 0xd3, 0x74, 0xe0, 0xfc, 0xab, 0x76, 0x5a, 0xc4, 0x5c,
	0x79, 0x55, 0xde, 0xaf, 0x2f, 0x5e, 0x4f, 0xad, 0xff, 0x5c, 0x31, 0x3d, 0x53, 0xe1, 0xfc, 0x85,
	0xd6, 0x18, 0x8c, 0x31, 0xf3, 0x3b, 0x82, 0x01, 0xe6, 0x31, 0xd3, 0x96, 0xda, 0x5e, 0x59, 0xc3,
	0x17, 0x06, 0x9d, 0x23, 0xa6, 0x4b, 0x97, 0x9f, 0x27, 0x3e, 0x4f, 0x56, 0x6f, 0x17, 0x6d, 0x18,
	0xa2, 0x0f, 0x01, 0x5c, 0x63, 0x41, 0x68, 0xa8, 0xec, 0xb6, 0xbd, 0x75, 0x9d, 0xf8, 0x2f, 0xc5,
	0x9d, 0x1a, 0x2a, 0x26, 0xe3, 0xd5, 0xb9, 0x0a, 0x8a, 0x57, 0x30, 0xb3, 0xd5, 0xe9, 0x6a, 0xa8,
	0x78, 0x95, 0xdc, 0xf9, 0xcc, 0xf8, 0x42, 0x8a, 0x1d, 0x88, 0xcf, 0x5e, 0x42, 0xe9, 0xc1, 0x4b,
	0xf8, 0x03, 0x95, 0x42, 0x98, 0x88, 0x99, 0xea, 0xb2, 0x22, 0x14, 0x25, 0x98, 0x68, 0xae, 0x5f,
	0x21, 0x57, 0x59, 0x7c, 0x14, 0x60, 0x32, 0x84, 0xf4, 0x2c, 0x1e, 0x0d, 0xe0, 0xfb, 0x6d, 0xae,
	0xa1, 0x62, 0x08, 0xe3, 0xd9, 0x20, 0xfd, 0x60, 0x0b, 0x21, 0x8c, 0xd3, 0x39, 0xaf, 0x2d, 0x33,
	0xe8, 0x7c, 0x40, 0xa2, 0xe8, 0x47, 0x07, 0xed, 0xa2, 0x8d, 0x88, 0xc1, 0x88, 0xd0, 0x98, 0x3f,
	0x9c, 0xb6, 0x9e, 0x24, 0x52, 0x3b, 0x1e, 0xaa, 0xb2, 0xbf, 0x54, 0x35, 0x34, 0xdf, 0xa9, 0x33,
	0x4a, 0x42, 0xd1, 0x0e, 0x7b, 0xd2, 0xf2, 0xaf, 0xed, 0xf7, 0x63, 0xdf, 0x50, 0xf9, 0xa0, 0x62,
	0xc6, 0x20, 0x14, 0x9d, 0x48, 0xb6, 0xe2, 0x66, 0xe1, 0x4b, 0x06, 0x55, 0xfd, 0x79, 0xfd, 0x08,
	0xad, 0xcf, 0xc6, 0x71, 0x0f, 0x38, 0x88, 0x27, 0xcf, 0x3a, 0x3c, 0x79, 0x77, 0x57, 0xb1, 0x6e,
	0xef, 0x2a, 0xd6, 0x87, 0xbb, 0x8a, 0xf5, 0xea, 0xbe, 0xb2, 0x74, 0x7b, 0x5f, 0x59, 0x7a, 0x7f,
	0x5f, 0x59, 0x7a, 0xf9, 0xf7, 0x35, 0x11, 0xfd, 0xb8, 0xdb, 0xec, 0xd1, 0x61, 0xeb, 0xf4, 0xc5,
	0xe5, 0xf1, 0x33, 0x10, 0x63, 0xca, 0x06, 0xad, 0x5e, 0x1f, 0x93, 0xb0, 0x35, 0x49, 0xff, 0x23,
	0x62, 0x1a, 0x01, 0xef, 0x66, 0xd4, 0x3f, 0xe4, 0x9f, 0x4f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb8,
	0xe3, 0xf5, 0xed, 0xc1, 0x06, 0x00, 0x00,
}

func (m *EventBundleVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBundleVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBundleVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vote != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Vote))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StorageId) > 0 {
		i -= len(m.StorageId)
		copy(dAtA[i:], m.StorageId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.StorageId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBundleProposed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBundleProposed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBundleProposed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompressionId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CompressionId))
		i--
		dAtA[i] = 0x70
	}
	if m.StorageProviderId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.StorageProviderId))
		i--
		dAtA[i] = 0x68
	}
	if m.ProposedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposedAt))
		i--
		dAtA[i] = 0x60
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.BundleSummary) > 0 {
		i -= len(m.BundleSummary)
		copy(dAtA[i:], m.BundleSummary)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BundleSummary)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ToKey) > 0 {
		i -= len(m.ToKey)
		copy(dAtA[i:], m.ToKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ToKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.FromKey) > 0 {
		i -= len(m.FromKey)
		copy(dAtA[i:], m.FromKey)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.FromKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.BundleSize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BundleSize))
		i--
		dAtA[i] = 0x38
	}
	if m.FromIndex != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FromIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.DataSize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StorageId) > 0 {
		i -= len(m.StorageId)
		copy(dAtA[i:], m.StorageId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.StorageId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBundleFinalized) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBundleFinalized) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBundleFinalized) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextUploader) > 0 {
		i -= len(m.NextUploader)
		copy(dAtA[i:], m.NextUploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NextUploader)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0x6a
	}
	if m.FinalizedAt != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FinalizedAt))
		i--
		dAtA[i] = 0x60
	}
	if m.RewardTotal != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RewardTotal))
		i--
		dAtA[i] = 0x58
	}
	if m.RewardDelegation != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RewardDelegation))
		i--
		dAtA[i] = 0x50
	}
	if m.RewardUploader != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RewardUploader))
		i--
		dAtA[i] = 0x48
	}
	if m.RewardTreasury != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RewardTreasury))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.Total != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x30
	}
	if m.Abstain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Abstain))
		i--
		dAtA[i] = 0x28
	}
	if m.Invalid != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Invalid))
		i--
		dAtA[i] = 0x20
	}
	if m.Valid != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Valid))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventClaimedUploaderRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventClaimedUploaderRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventClaimedUploaderRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewUploader) > 0 {
		i -= len(m.NewUploader)
		copy(dAtA[i:], m.NewUploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewUploader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventSkippedUploaderRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSkippedUploaderRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSkippedUploaderRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewUploader) > 0 {
		i -= len(m.NewUploader)
		copy(dAtA[i:], m.NewUploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewUploader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PreviousUploader) > 0 {
		i -= len(m.PreviousUploader)
		copy(dAtA[i:], m.PreviousUploader)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousUploader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventPointIncreased) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPointIncreased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPointIncreased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentPoints != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CurrentPoints))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventPointsReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPointsReset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPointsReset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventBundleVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.StorageId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Vote != 0 {
		n += 1 + sovEvents(uint64(m.Vote))
	}
	return n
}

func (m *EventBundleProposed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.StorageId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DataSize != 0 {
		n += 1 + sovEvents(uint64(m.DataSize))
	}
	if m.FromIndex != 0 {
		n += 1 + sovEvents(uint64(m.FromIndex))
	}
	if m.BundleSize != 0 {
		n += 1 + sovEvents(uint64(m.BundleSize))
	}
	l = len(m.FromKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ToKey)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BundleSummary)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProposedAt != 0 {
		n += 1 + sovEvents(uint64(m.ProposedAt))
	}
	if m.StorageProviderId != 0 {
		n += 1 + sovEvents(uint64(m.StorageProviderId))
	}
	if m.CompressionId != 0 {
		n += 1 + sovEvents(uint64(m.CompressionId))
	}
	return n
}

func (m *EventBundleFinalized) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	if m.Valid != 0 {
		n += 1 + sovEvents(uint64(m.Valid))
	}
	if m.Invalid != 0 {
		n += 1 + sovEvents(uint64(m.Invalid))
	}
	if m.Abstain != 0 {
		n += 1 + sovEvents(uint64(m.Abstain))
	}
	if m.Total != 0 {
		n += 1 + sovEvents(uint64(m.Total))
	}
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.RewardTreasury != 0 {
		n += 1 + sovEvents(uint64(m.RewardTreasury))
	}
	if m.RewardUploader != 0 {
		n += 1 + sovEvents(uint64(m.RewardUploader))
	}
	if m.RewardDelegation != 0 {
		n += 1 + sovEvents(uint64(m.RewardDelegation))
	}
	if m.RewardTotal != 0 {
		n += 1 + sovEvents(uint64(m.RewardTotal))
	}
	if m.FinalizedAt != 0 {
		n += 1 + sovEvents(uint64(m.FinalizedAt))
	}
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NextUploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventClaimedUploaderRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.NewUploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSkippedUploaderRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	if m.Id != 0 {
		n += 1 + sovEvents(uint64(m.Id))
	}
	l = len(m.PreviousUploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewUploader)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPointIncreased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.CurrentPoints != 0 {
		n += 1 + sovEvents(uint64(m.CurrentPoints))
	}
	return n
}

func (m *EventPointsReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovEvents(uint64(m.PoolId))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventBundleVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBundleVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBundleVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= VoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBundleProposed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBundleProposed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBundleProposed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromIndex", wireType)
			}
			m.FromIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSize", wireType)
			}
			m.BundleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleSummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedAt", wireType)
			}
			m.ProposedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageProviderId", wireType)
			}
			m.StorageProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageProviderId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionId", wireType)
			}
			m.CompressionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBundleFinalized) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBundleFinalized: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBundleFinalized: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			m.Valid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Valid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invalid", wireType)
			}
			m.Invalid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invalid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abstain", wireType)
			}
			m.Abstain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Abstain |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BundleStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTreasury", wireType)
			}
			m.RewardTreasury = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardTreasury |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardUploader", wireType)
			}
			m.RewardUploader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardUploader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDelegation", wireType)
			}
			m.RewardDelegation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardDelegation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTotal", wireType)
			}
			m.RewardTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedAt", wireType)
			}
			m.FinalizedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventClaimedUploaderRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventClaimedUploaderRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventClaimedUploaderRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSkippedUploaderRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSkippedUploaderRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSkippedUploaderRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPointIncreased) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPointIncreased: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPointIncreased: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPoints", wireType)
			}
			m.CurrentPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentPoints |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPointsReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPointsReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPointsReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
